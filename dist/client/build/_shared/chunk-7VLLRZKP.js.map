{
  "version": 3,
  "sources": ["../../../../node_modules/cookie/index.js", "../../../../node_modules/@shopify/remix-oxygen/node_modules/@remix-run/server-runtime/dist/esm/responses.js", "../../../../node_modules/@shopify/remix-oxygen/node_modules/@remix-run/server-runtime/dist/esm/cookies.js", "../../../../node_modules/@shopify/remix-oxygen/node_modules/@remix-run/server-runtime/dist/esm/warnings.js", "../../../../node_modules/@shopify/remix-oxygen/node_modules/@remix-run/server-runtime/dist/esm/sessions.js", "../../../../node_modules/@shopify/remix-oxygen/node_modules/@remix-run/server-runtime/dist/esm/sessions/cookieStorage.js", "../../../../node_modules/@shopify/remix-oxygen/node_modules/@remix-run/server-runtime/dist/esm/sessions/memoryStorage.js"],
  "sourcesContent": ["/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar decode = decodeURIComponent;\nvar encode = encodeURIComponent;\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var pairs = str.split(';')\n  var dec = opt.decode || decode;\n\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i];\n    var index = pair.indexOf('=')\n\n    // skip things that don't look like key=value\n    if (index < 0) {\n      continue;\n    }\n\n    var key = pair.substring(0, index).trim()\n\n    // only assign once\n    if (undefined == obj[key]) {\n      var val = pair.substring(index + 1, pair.length).trim()\n\n      // quoted values\n      if (val[0] === '\"') {\n        val = val.slice(1, -1)\n      }\n\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + opt.expires.toUTCString();\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n", "/**\n * @remix-run/server-runtime v1.15.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { json as json$1, defer as defer$1, redirect as redirect$1 } from '@remix-run/router';\nimport { serializeError } from './errors.js';\n\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n *\n * @see https://remix.run/utils/json\n */\nconst json = (data, init = {}) => {\n  return json$1(data, init);\n};\n\n/**\n * This is a shortcut for creating Remix deferred responses\n *\n * @see https://remix.run/docs/utils/defer\n */\nconst defer = (data, init = {}) => {\n  return defer$1(data, init);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n *\n * @see https://remix.run/utils/redirect\n */\nconst redirect = (url, init = 302) => {\n  return redirect$1(url, init);\n};\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nfunction isRedirectStatusCode(statusCode) {\n  return redirectStatusCodes.has(statusCode);\n}\nfunction isRedirectResponse(response) {\n  return isRedirectStatusCode(response.status);\n}\nfunction isTrackedPromise(value) {\n  return value != null && typeof value.then === \"function\" && value._tracked === true;\n}\n\n// TODO: Figure out why ReadableStream types are borked sooooooo badly\n// in this file. Probably related to our TS configurations and configs\n// bleeding into each other.\nconst DEFERRED_VALUE_PLACEHOLDER_PREFIX = \"__deferred_promise:\";\nfunction createDeferredReadableStream(deferredData, signal, serverMode) {\n  let encoder = new TextEncoder();\n  let stream = new ReadableStream({\n    async start(controller) {\n      let criticalData = {};\n      let preresolvedKeys = [];\n      for (let [key, value] of Object.entries(deferredData.data)) {\n        if (isTrackedPromise(value)) {\n          criticalData[key] = `${DEFERRED_VALUE_PLACEHOLDER_PREFIX}${key}`;\n          if (typeof value._data !== \"undefined\" || typeof value._error !== \"undefined\") {\n            preresolvedKeys.push(key);\n          }\n        } else {\n          criticalData[key] = value;\n        }\n      }\n\n      // Send the critical data\n      controller.enqueue(encoder.encode(JSON.stringify(criticalData) + \"\\n\\n\"));\n      for (let preresolvedKey of preresolvedKeys) {\n        enqueueTrackedPromise(controller, encoder, preresolvedKey, deferredData.data[preresolvedKey], serverMode);\n      }\n      let unsubscribe = deferredData.subscribe((aborted, settledKey) => {\n        if (settledKey) {\n          enqueueTrackedPromise(controller, encoder, settledKey, deferredData.data[settledKey], serverMode);\n        }\n      });\n      await deferredData.resolveData(signal);\n      unsubscribe();\n      controller.close();\n    }\n  });\n  return stream;\n}\nfunction enqueueTrackedPromise(controller, encoder, settledKey, promise, serverMode) {\n  if (\"_error\" in promise) {\n    controller.enqueue(encoder.encode(\"error:\" + JSON.stringify({\n      [settledKey]: promise._error instanceof Error ? serializeError(promise._error, serverMode) : promise._error\n    }) + \"\\n\\n\"));\n  } else {\n    controller.enqueue(encoder.encode(\"data:\" + JSON.stringify({\n      [settledKey]: promise._data ?? null\n    }) + \"\\n\\n\"));\n  }\n}\n\nexport { createDeferredReadableStream, defer, isDeferredData, isRedirectResponse, isRedirectStatusCode, isResponse, json, redirect };\n", "/**\n * @remix-run/server-runtime v1.15.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { parse, serialize } from 'cookie';\nimport { warnOnce } from './warnings.js';\n\n/**\n * Creates a logical container for managing a browser cookie from the server.\n *\n * @see https://remix.run/utils/cookies#createcookie\n */\nconst createCookieFactory = ({\n  sign,\n  unsign\n}) => (name, cookieOptions = {}) => {\n  let {\n    secrets,\n    ...options\n  } = {\n    secrets: [],\n    path: \"/\",\n    sameSite: \"lax\",\n    ...cookieOptions\n  };\n  warnOnceAboutExpiresCookie(name, options.expires);\n  return {\n    get name() {\n      return name;\n    },\n    get isSigned() {\n      return secrets.length > 0;\n    },\n    get expires() {\n      // Max-Age takes precedence over Expires\n      return typeof options.maxAge !== \"undefined\" ? new Date(Date.now() + options.maxAge * 1000) : options.expires;\n    },\n    async parse(cookieHeader, parseOptions) {\n      if (!cookieHeader) return null;\n      let cookies = parse(cookieHeader, {\n        ...options,\n        ...parseOptions\n      });\n      return name in cookies ? cookies[name] === \"\" ? \"\" : await decodeCookieValue(unsign, cookies[name], secrets) : null;\n    },\n    async serialize(value, serializeOptions) {\n      return serialize(name, value === \"\" ? \"\" : await encodeCookieValue(sign, value, secrets), {\n        ...options,\n        ...serializeOptions\n      });\n    }\n  };\n};\n/**\n * Returns true if an object is a Remix cookie container.\n *\n * @see https://remix.run/utils/cookies#iscookie\n */\nconst isCookie = object => {\n  return object != null && typeof object.name === \"string\" && typeof object.isSigned === \"boolean\" && typeof object.parse === \"function\" && typeof object.serialize === \"function\";\n};\nasync function encodeCookieValue(sign, value, secrets) {\n  let encoded = encodeData(value);\n  if (secrets.length > 0) {\n    encoded = await sign(encoded, secrets[0]);\n  }\n  return encoded;\n}\nasync function decodeCookieValue(unsign, value, secrets) {\n  if (secrets.length > 0) {\n    for (let secret of secrets) {\n      let unsignedValue = await unsign(value, secret);\n      if (unsignedValue !== false) {\n        return decodeData(unsignedValue);\n      }\n    }\n    return null;\n  }\n  return decodeData(value);\n}\nfunction encodeData(value) {\n  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));\n}\nfunction decodeData(value) {\n  try {\n    return JSON.parse(decodeURIComponent(myEscape(atob(value))));\n  } catch (error) {\n    return {};\n  }\n}\n\n// See: https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.escape.js\nfunction myEscape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, code;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (/[\\w*+\\-./@]/.exec(chr)) {\n      result += chr;\n    } else {\n      code = chr.charCodeAt(0);\n      if (code < 256) {\n        result += \"%\" + hex(code, 2);\n      } else {\n        result += \"%u\" + hex(code, 4).toUpperCase();\n      }\n    }\n  }\n  return result;\n}\nfunction hex(code, length) {\n  let result = code.toString(16);\n  while (result.length < length) result = \"0\" + result;\n  return result;\n}\n\n// See: https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.unescape.js\nfunction myUnescape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, part;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (chr === \"%\") {\n      if (str.charAt(index) === \"u\") {\n        part = str.slice(index + 1, index + 5);\n        if (/^[\\da-f]{4}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 5;\n          continue;\n        }\n      } else {\n        part = str.slice(index, index + 2);\n        if (/^[\\da-f]{2}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 2;\n          continue;\n        }\n      }\n    }\n    result += chr;\n  }\n  return result;\n}\nfunction warnOnceAboutExpiresCookie(name, expires) {\n  warnOnce(!expires, `The \"${name}\" cookie has an \"expires\" property set. ` + `This will cause the expires value to not be updated when the session is committed. ` + `Instead, you should set the expires value when serializing the cookie. ` + `You can use \\`commitSession(session, { expires })\\` if using a session storage object, ` + `or \\`cookie.serialize(\"value\", { expires })\\` if you're using the cookie directly.`);\n}\n\nexport { createCookieFactory, isCookie };\n", "/**\n * @remix-run/server-runtime v1.15.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nconst alreadyWarned = {};\nfunction warnOnce(condition, message) {\n  if (!condition && !alreadyWarned[message]) {\n    alreadyWarned[message] = true;\n    console.warn(message);\n  }\n}\n\nexport { warnOnce };\n", "/**\n * @remix-run/server-runtime v1.15.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { isCookie } from './cookies.js';\nimport { warnOnce } from './warnings.js';\n\n/**\n * An object of name/value pairs to be used in the session.\n */\n\nfunction flash(name) {\n  return `__flash_${name}__`;\n}\n/**\n * Creates a new Session object.\n *\n * Note: This function is typically not invoked directly by application code.\n * Instead, use a `SessionStorage` object's `getSession` method.\n *\n * @see https://remix.run/utils/sessions#createsession\n */\nconst createSession = (initialData = {}, id = \"\") => {\n  let map = new Map(Object.entries(initialData));\n  return {\n    get id() {\n      return id;\n    },\n    get data() {\n      return Object.fromEntries(map);\n    },\n    has(name) {\n      return map.has(name) || map.has(flash(name));\n    },\n    get(name) {\n      if (map.has(name)) return map.get(name);\n      let flashName = flash(name);\n      if (map.has(flashName)) {\n        let value = map.get(flashName);\n        map.delete(flashName);\n        return value;\n      }\n      return undefined;\n    },\n    set(name, value) {\n      map.set(name, value);\n    },\n    flash(name, value) {\n      map.set(flash(name), value);\n    },\n    unset(name) {\n      map.delete(name);\n    }\n  };\n};\n/**\n * Returns true if an object is a Remix session.\n *\n * @see https://remix.run/utils/sessions#issession\n */\nconst isSession = object => {\n  return object != null && typeof object.id === \"string\" && typeof object.data !== \"undefined\" && typeof object.has === \"function\" && typeof object.get === \"function\" && typeof object.set === \"function\" && typeof object.flash === \"function\" && typeof object.unset === \"function\";\n};\n\n/**\n * SessionStorage stores session data between HTTP requests and knows how to\n * parse and create cookies.\n *\n * A SessionStorage creates Session objects using a `Cookie` header as input.\n * Then, later it generates the `Set-Cookie` header to be used in the response.\n */\n\n/**\n * Creates a SessionStorage object using a SessionIdStorageStrategy.\n *\n * Note: This is a low-level API that should only be used if none of the\n * existing session storage options meet your requirements.\n *\n * @see https://remix.run/utils/sessions#createsessionstorage\n */\nconst createSessionStorageFactory = createCookie => ({\n  cookie: cookieArg,\n  createData,\n  readData,\n  updateData,\n  deleteData\n}) => {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie((cookieArg === null || cookieArg === void 0 ? void 0 : cookieArg.name) || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      let id = cookieHeader && (await cookie.parse(cookieHeader, options));\n      let data = id && (await readData(id));\n      return createSession(data || {}, id || \"\");\n    },\n    async commitSession(session, options) {\n      let {\n        id,\n        data\n      } = session;\n      if (id) {\n        await updateData(id, data, cookie.expires);\n      } else {\n        id = await createData(data, cookie.expires);\n      }\n      return cookie.serialize(id, options);\n    },\n    async destroySession(session, options) {\n      await deleteData(session.id);\n      return cookie.serialize(\"\", {\n        ...options,\n        expires: new Date(0)\n      });\n    }\n  };\n};\nfunction warnOnceAboutSigningSessionCookie(cookie) {\n  warnOnce(cookie.isSigned, `The \"${cookie.name}\" cookie is not signed, but session cookies should be ` + `signed to prevent tampering on the client before they are sent back to the ` + `server. See https://remix.run/utils/cookies#signing-cookies ` + `for more information.`);\n}\n\nexport { createSession, createSessionStorageFactory, isSession, warnOnceAboutSigningSessionCookie };\n", "/**\n * @remix-run/server-runtime v1.15.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { isCookie } from '../cookies.js';\nimport { warnOnceAboutSigningSessionCookie, createSession } from '../sessions.js';\n\n/**\n * Creates and returns a SessionStorage object that stores all session data\n * directly in the session cookie itself.\n *\n * This has the advantage that no database or other backend services are\n * needed, and can help to simplify some load-balanced scenarios. However, it\n * also has the limitation that serialized session data may not exceed the\n * browser's maximum cookie size. Trade-offs!\n *\n * @see https://remix.run/utils/sessions#createcookiesessionstorage\n */\nconst createCookieSessionStorageFactory = createCookie => ({\n  cookie: cookieArg\n} = {}) => {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie((cookieArg === null || cookieArg === void 0 ? void 0 : cookieArg.name) || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      return createSession(cookieHeader && (await cookie.parse(cookieHeader, options)) || {});\n    },\n    async commitSession(session, options) {\n      let serializedCookie = await cookie.serialize(session.data, options);\n      if (serializedCookie.length > 4096) {\n        throw new Error(\"Cookie length will exceed browser maximum. Length: \" + serializedCookie.length);\n      }\n      return serializedCookie;\n    },\n    async destroySession(_session, options) {\n      return cookie.serialize(\"\", {\n        ...options,\n        expires: new Date(0)\n      });\n    }\n  };\n};\n\nexport { createCookieSessionStorageFactory };\n", "/**\n * @remix-run/server-runtime v1.15.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n/**\n * Creates and returns a simple in-memory SessionStorage object, mostly useful\n * for testing and as a reference implementation.\n *\n * Note: This storage does not scale beyond a single process, so it is not\n * suitable for most production scenarios.\n *\n * @see https://remix.run/utils/sessions#creatememorysessionstorage\n */\nconst createMemorySessionStorageFactory = createSessionStorage => ({\n  cookie\n} = {}) => {\n  let uniqueId = 0;\n  let map = new Map();\n  return createSessionStorage({\n    cookie,\n    async createData(data, expires) {\n      let id = (++uniqueId).toString();\n      map.set(id, {\n        data,\n        expires\n      });\n      return id;\n    },\n    async readData(id) {\n      if (map.has(id)) {\n        let {\n          data,\n          expires\n        } = map.get(id);\n        if (!expires || expires > new Date()) {\n          return data;\n        }\n\n        // Remove expired session data.\n        if (expires) map.delete(id);\n      }\n      return null;\n    },\n    async updateData(id, data, expires) {\n      map.set(id, {\n        data,\n        expires\n      });\n    },\n    async deleteData(id) {\n      map.delete(id);\n    }\n  });\n};\n\nexport { createMemorySessionStorageFactory };\n"],
  "mappings": "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",
  "names": ["parse", "serialize", "i", "decode", "json"]
}
